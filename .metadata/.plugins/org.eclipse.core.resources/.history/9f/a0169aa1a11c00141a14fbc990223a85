import java.io.IOException;


public class DynamicProgrammingMaximumPathSum {
	
	/**
	 * en möjlig algoritm:
	 * Man börjar ifrån botten och går uppåt och sparar för varje "nummer" ovanför sin siffra och den siffran
	 * under som har högst värde. Detta bör resultera i att resultatet kommer stå på platsen längst upp.
	 * Problemet blir att organisera det så man lätt kan hålla ordning på det så strukturen följer den som den
	 * ser ut.
	 * Jag borde kunna spara den som den ser ut i en array alltså den översta hamnar på (0, 0) dem två nästa på
	 * (1, 0) och (1, 1). Sedan när ja börjar nerifrån så tar jag en rad åt gången och börjar på den näst sista
	 * och kollar helt enkelt på numret som står rakt under den på den positionen man är på(låt säga vi är på
	 * (4, 5)) då kollar man bara (5, 5) och den till höger om den, alltså (5, 6) och så väljer man den största
	 * och adderar till det numret som står på den positionen man är på och uppdaterar med det, sedan när man är
	 * färdig med den raden man är på så går man bara upp en rad och upprepar, detta gör man tills man når
	 * sista(översta) raden och när man gjort den så står resultatet överst där
	 */
	
	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		
		String[] grid = FileManager.readFileAsStrings("C:\\Users\\Mattis\\workspace\\projectEuler\\" +
				"maximumPathSum1\\src\\path.txt");
		int[][] gridMatrix = convertStringArrayToIntMatrix(grid, 20);
		
	}
	
	
	/**
	 * converts an string array to an int matrix, assumes that all the rows in the array are the same size
	 * @param array
	 * @return
	 */
	public static int[][] convertStringArrayToIntMatrix(String[] array, int rowLength){
		int[][] matrix = new int[array.length][rowLength];
		
		for(int i = 0; i < array.length; i++){
			String[] splitted = array[i].split(" ");
			for(int j = 0; j < rowLength; j++){
				matrix[i][j] = Integer.parseInt(splitted[j]);
			}
		}
		
		return matrix;
	}

}
